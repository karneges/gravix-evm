/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "./common.js";

export declare namespace IGravix {
  export type PositionStruct = {
    marketIdx: BigNumberish;
    positionType: BigNumberish;
    initialCollateral: BigNumberish;
    openFee: BigNumberish;
    openPrice: BigNumberish;
    markPrice: BigNumberish;
    leverage: BigNumberish;
    accUSDFundingPerShare: BigNumberish;
    borrowBaseRatePerHour: BigNumberish;
    baseSpreadRate: BigNumberish;
    closeFeeRate: BigNumberish;
    liquidationThresholdRate: BigNumberish;
    createdAt: BigNumberish;
  };

  export type PositionStructOutput = [
    marketIdx: bigint,
    positionType: bigint,
    initialCollateral: bigint,
    openFee: bigint,
    openPrice: bigint,
    markPrice: bigint,
    leverage: bigint,
    accUSDFundingPerShare: bigint,
    borrowBaseRatePerHour: bigint,
    baseSpreadRate: bigint,
    closeFeeRate: bigint,
    liquidationThresholdRate: bigint,
    createdAt: bigint
  ] & {
    marketIdx: bigint;
    positionType: bigint;
    initialCollateral: bigint;
    openFee: bigint;
    openPrice: bigint;
    markPrice: bigint;
    leverage: bigint;
    accUSDFundingPerShare: bigint;
    borrowBaseRatePerHour: bigint;
    baseSpreadRate: bigint;
    closeFeeRate: bigint;
    liquidationThresholdRate: bigint;
    createdAt: bigint;
  };

  export type PositionViewStruct = {
    position: IGravix.PositionStruct;
    positionSizeUSD: BigNumberish;
    closePrice: BigNumberish;
    borrowFee: BigNumberish;
    fundingFee: BigNumberish;
    closeFee: BigNumberish;
    liquidationPrice: BigNumberish;
    pnl: BigNumberish;
    liquidate: boolean;
    viewTime: BigNumberish;
  };

  export type PositionViewStructOutput = [
    position: IGravix.PositionStructOutput,
    positionSizeUSD: bigint,
    closePrice: bigint,
    borrowFee: bigint,
    fundingFee: bigint,
    closeFee: bigint,
    liquidationPrice: bigint,
    pnl: bigint,
    liquidate: boolean,
    viewTime: bigint
  ] & {
    position: IGravix.PositionStructOutput;
    positionSizeUSD: bigint;
    closePrice: bigint;
    borrowFee: bigint;
    fundingFee: bigint;
    closeFee: bigint;
    liquidationPrice: bigint;
    pnl: bigint;
    liquidate: boolean;
    viewTime: bigint;
  };

  export type FeesStruct = {
    openFeeRate: BigNumberish;
    closeFeeRate: BigNumberish;
    baseSpreadRate: BigNumberish;
    baseDynamicSpreadRate: BigNumberish;
    borrowBaseRatePerHour: BigNumberish;
    fundingBaseRatePerHour: BigNumberish;
  };

  export type FeesStructOutput = [
    openFeeRate: bigint,
    closeFeeRate: bigint,
    baseSpreadRate: bigint,
    baseDynamicSpreadRate: bigint,
    borrowBaseRatePerHour: bigint,
    fundingBaseRatePerHour: bigint
  ] & {
    openFeeRate: bigint;
    closeFeeRate: bigint;
    baseSpreadRate: bigint;
    baseDynamicSpreadRate: bigint;
    borrowBaseRatePerHour: bigint;
    fundingBaseRatePerHour: bigint;
  };

  export type MarketConfigStruct = {
    maxLongsUSD: BigNumberish;
    maxShortsUSD: BigNumberish;
    noiWeight: BigNumberish;
    maxLeverage: BigNumberish;
    depthAsset: BigNumberish;
    ticker: string;
    fees: IGravix.FeesStruct;
  };

  export type MarketConfigStructOutput = [
    maxLongsUSD: bigint,
    maxShortsUSD: bigint,
    noiWeight: bigint,
    maxLeverage: bigint,
    depthAsset: bigint,
    ticker: string,
    fees: IGravix.FeesStructOutput
  ] & {
    maxLongsUSD: bigint;
    maxShortsUSD: bigint;
    noiWeight: bigint;
    maxLeverage: bigint;
    depthAsset: bigint;
    ticker: string;
    fees: IGravix.FeesStructOutput;
  };

  export type FundingStruct = {
    accLongUSDFundingPerShare: BigNumberish;
    accShortUSDFundingPerShare: BigNumberish;
  };

  export type FundingStructOutput = [
    accLongUSDFundingPerShare: bigint,
    accShortUSDFundingPerShare: bigint
  ] & { accLongUSDFundingPerShare: bigint; accShortUSDFundingPerShare: bigint };

  export type MarketStruct = {
    totalLongsAsset: BigNumberish;
    totalShortsAsset: BigNumberish;
    maxTotalLongsUSD: BigNumberish;
    maxTotalShortsUSD: BigNumberish;
    lastNoiUpdatePrice: BigNumberish;
    noiWeight: BigNumberish;
    funding: IGravix.FundingStruct;
    lastFundingUpdateTime: BigNumberish;
    maxLeverage: BigNumberish;
    depthAsset: BigNumberish;
    fees: IGravix.FeesStruct;
    paused: boolean;
  };

  export type MarketStructOutput = [
    totalLongsAsset: bigint,
    totalShortsAsset: bigint,
    maxTotalLongsUSD: bigint,
    maxTotalShortsUSD: bigint,
    lastNoiUpdatePrice: bigint,
    noiWeight: bigint,
    funding: IGravix.FundingStructOutput,
    lastFundingUpdateTime: bigint,
    maxLeverage: bigint,
    depthAsset: bigint,
    fees: IGravix.FeesStructOutput,
    paused: boolean
  ] & {
    totalLongsAsset: bigint;
    totalShortsAsset: bigint;
    maxTotalLongsUSD: bigint;
    maxTotalShortsUSD: bigint;
    lastNoiUpdatePrice: bigint;
    noiWeight: bigint;
    funding: IGravix.FundingStructOutput;
    lastFundingUpdateTime: bigint;
    maxLeverage: bigint;
    depthAsset: bigint;
    fees: IGravix.FeesStructOutput;
    paused: boolean;
  };

  export type MarketInfoStruct = {
    marketIdx: BigNumberish;
    ticker: string;
    market: IGravix.MarketStruct;
  };

  export type MarketInfoStructOutput = [
    marketIdx: bigint,
    ticker: string,
    market: IGravix.MarketStructOutput
  ] & { marketIdx: bigint; ticker: string; market: IGravix.MarketStructOutput };

  export type TreasuriesStruct = {
    treasury: AddressLike;
    projectFund: AddressLike;
    devFund: AddressLike;
  };

  export type TreasuriesStructOutput = [
    treasury: string,
    projectFund: string,
    devFund: string
  ] & { treasury: string; projectFund: string; devFund: string };

  export type PoolAssetsStruct = {
    balance: BigNumberish;
    stgUsdtSupply: BigNumberish;
    targetPrice: BigNumberish;
  };

  export type PoolAssetsStructOutput = [
    balance: bigint,
    stgUsdtSupply: bigint,
    targetPrice: bigint
  ] & { balance: bigint; stgUsdtSupply: bigint; targetPrice: bigint };

  export type InsuranceFundStruct = {
    balance: BigNumberish;
    limit: BigNumberish;
  };

  export type InsuranceFundStructOutput = [balance: bigint, limit: bigint] & {
    balance: bigint;
    limit: bigint;
  };

  export type LiquidationParamsStruct = {
    thresholdRate: BigNumberish;
    rewardShare: BigNumberish;
  };

  export type LiquidationParamsStructOutput = [
    thresholdRate: bigint,
    rewardShare: bigint
  ] & { thresholdRate: bigint; rewardShare: bigint };

  export type DetailsStruct = {
    priceNode: AddressLike;
    usdt: AddressLike;
    stgUsdt: AddressLike;
    treasuries: IGravix.TreasuriesStruct;
    poolAssets: IGravix.PoolAssetsStruct;
    insuranceFunds: IGravix.InsuranceFundStruct;
    insuranceFundOverflowDistributionSchema: [
      BigNumberish,
      BigNumberish,
      BigNumberish
    ];
    collateralReserve: BigNumberish;
    totalNOI: BigNumberish;
    totalNOILimitEnabled: boolean;
    maxPoolUtilRatio: BigNumberish;
    maxPnlRate: BigNumberish;
    minPositionCollateral: BigNumberish;
    paused: boolean;
    liquidation: IGravix.LiquidationParamsStruct;
    openFeeDistributionSchema: [BigNumberish, BigNumberish];
    closeFeeDistributionSchema: [BigNumberish, BigNumberish];
    marketCount: BigNumberish;
  };

  export type DetailsStructOutput = [
    priceNode: string,
    usdt: string,
    stgUsdt: string,
    treasuries: IGravix.TreasuriesStructOutput,
    poolAssets: IGravix.PoolAssetsStructOutput,
    insuranceFunds: IGravix.InsuranceFundStructOutput,
    insuranceFundOverflowDistributionSchema: [bigint, bigint, bigint],
    collateralReserve: bigint,
    totalNOI: bigint,
    totalNOILimitEnabled: boolean,
    maxPoolUtilRatio: bigint,
    maxPnlRate: bigint,
    minPositionCollateral: bigint,
    paused: boolean,
    liquidation: IGravix.LiquidationParamsStructOutput,
    openFeeDistributionSchema: [bigint, bigint],
    closeFeeDistributionSchema: [bigint, bigint],
    marketCount: bigint
  ] & {
    priceNode: string;
    usdt: string;
    stgUsdt: string;
    treasuries: IGravix.TreasuriesStructOutput;
    poolAssets: IGravix.PoolAssetsStructOutput;
    insuranceFunds: IGravix.InsuranceFundStructOutput;
    insuranceFundOverflowDistributionSchema: [bigint, bigint, bigint];
    collateralReserve: bigint;
    totalNOI: bigint;
    totalNOILimitEnabled: boolean;
    maxPoolUtilRatio: bigint;
    maxPnlRate: bigint;
    minPositionCollateral: bigint;
    paused: boolean;
    liquidation: IGravix.LiquidationParamsStructOutput;
    openFeeDistributionSchema: [bigint, bigint];
    closeFeeDistributionSchema: [bigint, bigint];
    marketCount: bigint;
  };

  export type ViewInputStruct = {
    positionKey: BigNumberish;
    user: AddressLike;
    assetPrice: BigNumberish;
    funding: IGravix.FundingStruct;
  };

  export type ViewInputStructOutput = [
    positionKey: bigint,
    user: string,
    assetPrice: bigint,
    funding: IGravix.FundingStructOutput
  ] & {
    positionKey: bigint;
    user: string;
    assetPrice: bigint;
    funding: IGravix.FundingStructOutput;
  };

  export type UserPositionInfoStruct = {
    positionIdx: BigNumberish;
    position: IGravix.PositionStruct;
  };

  export type UserPositionInfoStructOutput = [
    positionIdx: bigint,
    position: IGravix.PositionStructOutput
  ] & { positionIdx: bigint; position: IGravix.PositionStructOutput };

  export type PositionIdxStruct = {
    user: AddressLike;
    positionKey: BigNumberish;
  };

  export type PositionIdxStructOutput = [user: string, positionKey: bigint] & {
    user: string;
    positionKey: bigint;
  };

  export type LiquidationConfigStruct = {
    marketIdx: BigNumberish;
    assetPrice: BigNumberish;
    timestamp: BigNumberish;
    signature: BytesLike;
    positions: IGravix.PositionIdxStruct[];
  };

  export type LiquidationConfigStructOutput = [
    marketIdx: bigint,
    assetPrice: bigint,
    timestamp: bigint,
    signature: string,
    positions: IGravix.PositionIdxStructOutput[]
  ] & {
    marketIdx: bigint;
    assetPrice: bigint;
    timestamp: bigint;
    signature: string;
    positions: IGravix.PositionIdxStructOutput[];
  };
}

export interface GravixInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "addMarkets"
      | "applyOpenSpread"
      | "calculatePositionAssetSize"
      | "closeMarketPosition"
      | "depositLiquidity"
      | "getAllMarkets"
      | "getDetails"
      | "getDynamicSpread"
      | "getPositionView"
      | "getUserPositions"
      | "insuranceFund"
      | "liquidatePositions"
      | "liquidationParams"
      | "marketTickers"
      | "markets"
      | "openMarketPosition"
      | "owner"
      | "poolAssets"
      | "poolDebt"
      | "positions"
      | "priceNode"
      | "renounceOwnership"
      | "requestNonce"
      | "stgUsdt"
      | "stgUsdtPrice"
      | "stgUsdtToUsdt"
      | "transferOwnership"
      | "usdt"
      | "usdtToStgUsdt"
      | "userPositionCount"
      | "validateMarketConfig"
      | "withdrawLiquidity"
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic:
      | "ClosePosition"
      | "Debt"
      | "InsuranceFundDeposit"
      | "LiquidatePosition"
      | "LiquidityPoolDeposit"
      | "LiquidityPoolFees"
      | "LiquidityPoolWithdraw"
      | "MarketOrderExecution"
      | "NewMarket"
      | "OwnershipTransferred"
  ): EventFragment;

  encodeFunctionData(
    functionFragment: "addMarkets",
    values: [IGravix.MarketConfigStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "applyOpenSpread",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "calculatePositionAssetSize",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "closeMarketPosition",
    values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "depositLiquidity",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getAllMarkets",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getDetails",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getDynamicSpread",
    values: [BigNumberish, IGravix.MarketStruct, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getPositionView",
    values: [IGravix.ViewInputStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "getUserPositions",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "insuranceFund",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "liquidatePositions",
    values: [IGravix.LiquidationConfigStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "liquidationParams",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "marketTickers",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "markets",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "openMarketPosition",
    values: [
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BytesLike
    ]
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "poolAssets",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "poolDebt", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "positions",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "priceNode", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "requestNonce",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "stgUsdt", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "stgUsdtPrice",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "stgUsdtToUsdt",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [AddressLike]
  ): string;
  encodeFunctionData(functionFragment: "usdt", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "usdtToStgUsdt",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "userPositionCount",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "validateMarketConfig",
    values: [IGravix.MarketConfigStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawLiquidity",
    values: [BigNumberish]
  ): string;

  decodeFunctionResult(functionFragment: "addMarkets", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "applyOpenSpread",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "calculatePositionAssetSize",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "closeMarketPosition",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "depositLiquidity",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAllMarkets",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getDetails", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getDynamicSpread",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getPositionView",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getUserPositions",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "insuranceFund",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "liquidatePositions",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "liquidationParams",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "marketTickers",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "markets", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "openMarketPosition",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "poolAssets", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "poolDebt", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "positions", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "priceNode", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "requestNonce",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "stgUsdt", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "stgUsdtPrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "stgUsdtToUsdt",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "usdt", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "usdtToStgUsdt",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "userPositionCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "validateMarketConfig",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "withdrawLiquidity",
    data: BytesLike
  ): Result;
}

export namespace ClosePositionEvent {
  export type InputTuple = [
    user: AddressLike,
    positionKey: BigNumberish,
    positionView: IGravix.PositionViewStruct
  ];
  export type OutputTuple = [
    user: string,
    positionKey: bigint,
    positionView: IGravix.PositionViewStructOutput
  ];
  export interface OutputObject {
    user: string;
    positionKey: bigint;
    positionView: IGravix.PositionViewStructOutput;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace DebtEvent {
  export type InputTuple = [user: AddressLike, debt: BigNumberish];
  export type OutputTuple = [user: string, debt: bigint];
  export interface OutputObject {
    user: string;
    debt: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace InsuranceFundDepositEvent {
  export type InputTuple = [user: AddressLike, amount: BigNumberish];
  export type OutputTuple = [user: string, amount: bigint];
  export interface OutputObject {
    user: string;
    amount: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace LiquidatePositionEvent {
  export type InputTuple = [
    user: AddressLike,
    liquidator: AddressLike,
    positionKey: BigNumberish,
    positionView: IGravix.PositionViewStruct
  ];
  export type OutputTuple = [
    user: string,
    liquidator: string,
    positionKey: bigint,
    positionView: IGravix.PositionViewStructOutput
  ];
  export interface OutputObject {
    user: string;
    liquidator: string;
    positionKey: bigint;
    positionView: IGravix.PositionViewStructOutput;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace LiquidityPoolDepositEvent {
  export type InputTuple = [
    user: AddressLike,
    usdtAmountIn: BigNumberish,
    stgUsdtAmountOut: BigNumberish
  ];
  export type OutputTuple = [
    user: string,
    usdtAmountIn: bigint,
    stgUsdtAmountOut: bigint
  ];
  export interface OutputObject {
    user: string;
    usdtAmountIn: bigint;
    stgUsdtAmountOut: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace LiquidityPoolFeesEvent {
  export type InputTuple = [fees: BigNumberish];
  export type OutputTuple = [fees: bigint];
  export interface OutputObject {
    fees: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace LiquidityPoolWithdrawEvent {
  export type InputTuple = [
    user: AddressLike,
    usdtAmountOut: BigNumberish,
    stgUsdtAmountIn: BigNumberish
  ];
  export type OutputTuple = [
    user: string,
    usdtAmountOut: bigint,
    stgUsdtAmountIn: bigint
  ];
  export interface OutputObject {
    user: string;
    usdtAmountOut: bigint;
    stgUsdtAmountIn: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace MarketOrderExecutionEvent {
  export type InputTuple = [
    user: AddressLike,
    position: IGravix.PositionStruct,
    positionKey: BigNumberish
  ];
  export type OutputTuple = [
    user: string,
    position: IGravix.PositionStructOutput,
    positionKey: bigint
  ];
  export interface OutputObject {
    user: string;
    position: IGravix.PositionStructOutput;
    positionKey: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace NewMarketEvent {
  export type InputTuple = [market: IGravix.MarketConfigStruct];
  export type OutputTuple = [market: IGravix.MarketConfigStructOutput];
  export interface OutputObject {
    market: IGravix.MarketConfigStructOutput;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace OwnershipTransferredEvent {
  export type InputTuple = [previousOwner: AddressLike, newOwner: AddressLike];
  export type OutputTuple = [previousOwner: string, newOwner: string];
  export interface OutputObject {
    previousOwner: string;
    newOwner: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface Gravix extends BaseContract {
  connect(runner?: ContractRunner | null): Gravix;
  waitForDeployment(): Promise<this>;

  interface: GravixInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  addMarkets: TypedContractMethod<
    [newMarkets: IGravix.MarketConfigStruct[]],
    [void],
    "nonpayable"
  >;

  applyOpenSpread: TypedContractMethod<
    [price: BigNumberish, _type: BigNumberish, spread: BigNumberish],
    [bigint],
    "nonpayable"
  >;

  calculatePositionAssetSize: TypedContractMethod<
    [
      collateral: BigNumberish,
      leverage: BigNumberish,
      assetPrice: BigNumberish
    ],
    [bigint],
    "view"
  >;

  closeMarketPosition: TypedContractMethod<
    [
      marketIdx: BigNumberish,
      positionKey: BigNumberish,
      _assetPrice: BigNumberish,
      timestamp: BigNumberish,
      signature: BytesLike
    ],
    [void],
    "nonpayable"
  >;

  depositLiquidity: TypedContractMethod<
    [amount: BigNumberish],
    [void],
    "nonpayable"
  >;

  getAllMarkets: TypedContractMethod<
    [],
    [IGravix.MarketInfoStructOutput[]],
    "view"
  >;

  getDetails: TypedContractMethod<[], [IGravix.DetailsStructOutput], "view">;

  getDynamicSpread: TypedContractMethod<
    [
      positionSizeAsset: BigNumberish,
      _market: IGravix.MarketStruct,
      positionType: BigNumberish
    ],
    [bigint],
    "view"
  >;

  getPositionView: TypedContractMethod<
    [input: IGravix.ViewInputStruct],
    [IGravix.PositionViewStructOutput],
    "view"
  >;

  getUserPositions: TypedContractMethod<
    [user: AddressLike],
    [IGravix.UserPositionInfoStructOutput[]],
    "view"
  >;

  insuranceFund: TypedContractMethod<
    [],
    [[bigint, bigint] & { balance: bigint; limit: bigint }],
    "view"
  >;

  liquidatePositions: TypedContractMethod<
    [liquidationConfig: IGravix.LiquidationConfigStruct[]],
    [void],
    "nonpayable"
  >;

  liquidationParams: TypedContractMethod<
    [],
    [[bigint, bigint] & { thresholdRate: bigint; rewardShare: bigint }],
    "view"
  >;

  marketTickers: TypedContractMethod<[arg0: BigNumberish], [string], "view">;

  markets: TypedContractMethod<
    [arg0: BigNumberish],
    [
      [
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        IGravix.FundingStructOutput,
        bigint,
        bigint,
        bigint,
        IGravix.FeesStructOutput,
        boolean
      ] & {
        totalLongsAsset: bigint;
        totalShortsAsset: bigint;
        maxTotalLongsUSD: bigint;
        maxTotalShortsUSD: bigint;
        lastNoiUpdatePrice: bigint;
        noiWeight: bigint;
        funding: IGravix.FundingStructOutput;
        lastFundingUpdateTime: bigint;
        maxLeverage: bigint;
        depthAsset: bigint;
        fees: IGravix.FeesStructOutput;
        paused: boolean;
      }
    ],
    "view"
  >;

  openMarketPosition: TypedContractMethod<
    [
      marketIdx: BigNumberish,
      positionType: BigNumberish,
      collateral: BigNumberish,
      expectedPrice: BigNumberish,
      leverage: BigNumberish,
      maxSlippageRate: BigNumberish,
      _assetPrice: BigNumberish,
      timestamp: BigNumberish,
      signature: BytesLike
    ],
    [void],
    "nonpayable"
  >;

  owner: TypedContractMethod<[], [string], "view">;

  poolAssets: TypedContractMethod<
    [],
    [
      [bigint, bigint, bigint] & {
        balance: bigint;
        stgUsdtSupply: bigint;
        targetPrice: bigint;
      }
    ],
    "view"
  >;

  poolDebt: TypedContractMethod<[], [bigint], "view">;

  positions: TypedContractMethod<
    [arg0: AddressLike, arg1: BigNumberish],
    [
      [
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint
      ] & {
        marketIdx: bigint;
        positionType: bigint;
        initialCollateral: bigint;
        openFee: bigint;
        openPrice: bigint;
        markPrice: bigint;
        leverage: bigint;
        accUSDFundingPerShare: bigint;
        borrowBaseRatePerHour: bigint;
        baseSpreadRate: bigint;
        closeFeeRate: bigint;
        liquidationThresholdRate: bigint;
        createdAt: bigint;
      }
    ],
    "view"
  >;

  priceNode: TypedContractMethod<[], [string], "view">;

  renounceOwnership: TypedContractMethod<[], [void], "nonpayable">;

  requestNonce: TypedContractMethod<[], [bigint], "view">;

  stgUsdt: TypedContractMethod<[], [string], "view">;

  stgUsdtPrice: TypedContractMethod<
    [],
    [[bigint, bigint] & { inPrice: bigint; outPrice: bigint }],
    "view"
  >;

  stgUsdtToUsdt: TypedContractMethod<
    [stgAmount: BigNumberish],
    [bigint],
    "view"
  >;

  transferOwnership: TypedContractMethod<
    [newOwner: AddressLike],
    [void],
    "nonpayable"
  >;

  usdt: TypedContractMethod<[], [string], "view">;

  usdtToStgUsdt: TypedContractMethod<
    [usdtAmount: BigNumberish],
    [bigint],
    "view"
  >;

  userPositionCount: TypedContractMethod<[arg0: AddressLike], [bigint], "view">;

  validateMarketConfig: TypedContractMethod<
    [config: IGravix.MarketConfigStruct],
    [boolean],
    "view"
  >;

  withdrawLiquidity: TypedContractMethod<
    [stgUsdtAmount: BigNumberish],
    [void],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "addMarkets"
  ): TypedContractMethod<
    [newMarkets: IGravix.MarketConfigStruct[]],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "applyOpenSpread"
  ): TypedContractMethod<
    [price: BigNumberish, _type: BigNumberish, spread: BigNumberish],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "calculatePositionAssetSize"
  ): TypedContractMethod<
    [
      collateral: BigNumberish,
      leverage: BigNumberish,
      assetPrice: BigNumberish
    ],
    [bigint],
    "view"
  >;
  getFunction(
    nameOrSignature: "closeMarketPosition"
  ): TypedContractMethod<
    [
      marketIdx: BigNumberish,
      positionKey: BigNumberish,
      _assetPrice: BigNumberish,
      timestamp: BigNumberish,
      signature: BytesLike
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "depositLiquidity"
  ): TypedContractMethod<[amount: BigNumberish], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "getAllMarkets"
  ): TypedContractMethod<[], [IGravix.MarketInfoStructOutput[]], "view">;
  getFunction(
    nameOrSignature: "getDetails"
  ): TypedContractMethod<[], [IGravix.DetailsStructOutput], "view">;
  getFunction(
    nameOrSignature: "getDynamicSpread"
  ): TypedContractMethod<
    [
      positionSizeAsset: BigNumberish,
      _market: IGravix.MarketStruct,
      positionType: BigNumberish
    ],
    [bigint],
    "view"
  >;
  getFunction(
    nameOrSignature: "getPositionView"
  ): TypedContractMethod<
    [input: IGravix.ViewInputStruct],
    [IGravix.PositionViewStructOutput],
    "view"
  >;
  getFunction(
    nameOrSignature: "getUserPositions"
  ): TypedContractMethod<
    [user: AddressLike],
    [IGravix.UserPositionInfoStructOutput[]],
    "view"
  >;
  getFunction(
    nameOrSignature: "insuranceFund"
  ): TypedContractMethod<
    [],
    [[bigint, bigint] & { balance: bigint; limit: bigint }],
    "view"
  >;
  getFunction(
    nameOrSignature: "liquidatePositions"
  ): TypedContractMethod<
    [liquidationConfig: IGravix.LiquidationConfigStruct[]],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "liquidationParams"
  ): TypedContractMethod<
    [],
    [[bigint, bigint] & { thresholdRate: bigint; rewardShare: bigint }],
    "view"
  >;
  getFunction(
    nameOrSignature: "marketTickers"
  ): TypedContractMethod<[arg0: BigNumberish], [string], "view">;
  getFunction(
    nameOrSignature: "markets"
  ): TypedContractMethod<
    [arg0: BigNumberish],
    [
      [
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        IGravix.FundingStructOutput,
        bigint,
        bigint,
        bigint,
        IGravix.FeesStructOutput,
        boolean
      ] & {
        totalLongsAsset: bigint;
        totalShortsAsset: bigint;
        maxTotalLongsUSD: bigint;
        maxTotalShortsUSD: bigint;
        lastNoiUpdatePrice: bigint;
        noiWeight: bigint;
        funding: IGravix.FundingStructOutput;
        lastFundingUpdateTime: bigint;
        maxLeverage: bigint;
        depthAsset: bigint;
        fees: IGravix.FeesStructOutput;
        paused: boolean;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "openMarketPosition"
  ): TypedContractMethod<
    [
      marketIdx: BigNumberish,
      positionType: BigNumberish,
      collateral: BigNumberish,
      expectedPrice: BigNumberish,
      leverage: BigNumberish,
      maxSlippageRate: BigNumberish,
      _assetPrice: BigNumberish,
      timestamp: BigNumberish,
      signature: BytesLike
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "owner"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "poolAssets"
  ): TypedContractMethod<
    [],
    [
      [bigint, bigint, bigint] & {
        balance: bigint;
        stgUsdtSupply: bigint;
        targetPrice: bigint;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "poolDebt"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "positions"
  ): TypedContractMethod<
    [arg0: AddressLike, arg1: BigNumberish],
    [
      [
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint
      ] & {
        marketIdx: bigint;
        positionType: bigint;
        initialCollateral: bigint;
        openFee: bigint;
        openPrice: bigint;
        markPrice: bigint;
        leverage: bigint;
        accUSDFundingPerShare: bigint;
        borrowBaseRatePerHour: bigint;
        baseSpreadRate: bigint;
        closeFeeRate: bigint;
        liquidationThresholdRate: bigint;
        createdAt: bigint;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "priceNode"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "renounceOwnership"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "requestNonce"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "stgUsdt"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "stgUsdtPrice"
  ): TypedContractMethod<
    [],
    [[bigint, bigint] & { inPrice: bigint; outPrice: bigint }],
    "view"
  >;
  getFunction(
    nameOrSignature: "stgUsdtToUsdt"
  ): TypedContractMethod<[stgAmount: BigNumberish], [bigint], "view">;
  getFunction(
    nameOrSignature: "transferOwnership"
  ): TypedContractMethod<[newOwner: AddressLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "usdt"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "usdtToStgUsdt"
  ): TypedContractMethod<[usdtAmount: BigNumberish], [bigint], "view">;
  getFunction(
    nameOrSignature: "userPositionCount"
  ): TypedContractMethod<[arg0: AddressLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "validateMarketConfig"
  ): TypedContractMethod<
    [config: IGravix.MarketConfigStruct],
    [boolean],
    "view"
  >;
  getFunction(
    nameOrSignature: "withdrawLiquidity"
  ): TypedContractMethod<[stgUsdtAmount: BigNumberish], [void], "nonpayable">;

  getEvent(
    key: "ClosePosition"
  ): TypedContractEvent<
    ClosePositionEvent.InputTuple,
    ClosePositionEvent.OutputTuple,
    ClosePositionEvent.OutputObject
  >;
  getEvent(
    key: "Debt"
  ): TypedContractEvent<
    DebtEvent.InputTuple,
    DebtEvent.OutputTuple,
    DebtEvent.OutputObject
  >;
  getEvent(
    key: "InsuranceFundDeposit"
  ): TypedContractEvent<
    InsuranceFundDepositEvent.InputTuple,
    InsuranceFundDepositEvent.OutputTuple,
    InsuranceFundDepositEvent.OutputObject
  >;
  getEvent(
    key: "LiquidatePosition"
  ): TypedContractEvent<
    LiquidatePositionEvent.InputTuple,
    LiquidatePositionEvent.OutputTuple,
    LiquidatePositionEvent.OutputObject
  >;
  getEvent(
    key: "LiquidityPoolDeposit"
  ): TypedContractEvent<
    LiquidityPoolDepositEvent.InputTuple,
    LiquidityPoolDepositEvent.OutputTuple,
    LiquidityPoolDepositEvent.OutputObject
  >;
  getEvent(
    key: "LiquidityPoolFees"
  ): TypedContractEvent<
    LiquidityPoolFeesEvent.InputTuple,
    LiquidityPoolFeesEvent.OutputTuple,
    LiquidityPoolFeesEvent.OutputObject
  >;
  getEvent(
    key: "LiquidityPoolWithdraw"
  ): TypedContractEvent<
    LiquidityPoolWithdrawEvent.InputTuple,
    LiquidityPoolWithdrawEvent.OutputTuple,
    LiquidityPoolWithdrawEvent.OutputObject
  >;
  getEvent(
    key: "MarketOrderExecution"
  ): TypedContractEvent<
    MarketOrderExecutionEvent.InputTuple,
    MarketOrderExecutionEvent.OutputTuple,
    MarketOrderExecutionEvent.OutputObject
  >;
  getEvent(
    key: "NewMarket"
  ): TypedContractEvent<
    NewMarketEvent.InputTuple,
    NewMarketEvent.OutputTuple,
    NewMarketEvent.OutputObject
  >;
  getEvent(
    key: "OwnershipTransferred"
  ): TypedContractEvent<
    OwnershipTransferredEvent.InputTuple,
    OwnershipTransferredEvent.OutputTuple,
    OwnershipTransferredEvent.OutputObject
  >;

  filters: {
    "ClosePosition(address,uint256,tuple)": TypedContractEvent<
      ClosePositionEvent.InputTuple,
      ClosePositionEvent.OutputTuple,
      ClosePositionEvent.OutputObject
    >;
    ClosePosition: TypedContractEvent<
      ClosePositionEvent.InputTuple,
      ClosePositionEvent.OutputTuple,
      ClosePositionEvent.OutputObject
    >;

    "Debt(address,uint256)": TypedContractEvent<
      DebtEvent.InputTuple,
      DebtEvent.OutputTuple,
      DebtEvent.OutputObject
    >;
    Debt: TypedContractEvent<
      DebtEvent.InputTuple,
      DebtEvent.OutputTuple,
      DebtEvent.OutputObject
    >;

    "InsuranceFundDeposit(address,uint256)": TypedContractEvent<
      InsuranceFundDepositEvent.InputTuple,
      InsuranceFundDepositEvent.OutputTuple,
      InsuranceFundDepositEvent.OutputObject
    >;
    InsuranceFundDeposit: TypedContractEvent<
      InsuranceFundDepositEvent.InputTuple,
      InsuranceFundDepositEvent.OutputTuple,
      InsuranceFundDepositEvent.OutputObject
    >;

    "LiquidatePosition(address,address,uint256,tuple)": TypedContractEvent<
      LiquidatePositionEvent.InputTuple,
      LiquidatePositionEvent.OutputTuple,
      LiquidatePositionEvent.OutputObject
    >;
    LiquidatePosition: TypedContractEvent<
      LiquidatePositionEvent.InputTuple,
      LiquidatePositionEvent.OutputTuple,
      LiquidatePositionEvent.OutputObject
    >;

    "LiquidityPoolDeposit(address,uint256,uint256)": TypedContractEvent<
      LiquidityPoolDepositEvent.InputTuple,
      LiquidityPoolDepositEvent.OutputTuple,
      LiquidityPoolDepositEvent.OutputObject
    >;
    LiquidityPoolDeposit: TypedContractEvent<
      LiquidityPoolDepositEvent.InputTuple,
      LiquidityPoolDepositEvent.OutputTuple,
      LiquidityPoolDepositEvent.OutputObject
    >;

    "LiquidityPoolFees(uint256)": TypedContractEvent<
      LiquidityPoolFeesEvent.InputTuple,
      LiquidityPoolFeesEvent.OutputTuple,
      LiquidityPoolFeesEvent.OutputObject
    >;
    LiquidityPoolFees: TypedContractEvent<
      LiquidityPoolFeesEvent.InputTuple,
      LiquidityPoolFeesEvent.OutputTuple,
      LiquidityPoolFeesEvent.OutputObject
    >;

    "LiquidityPoolWithdraw(address,uint256,uint256)": TypedContractEvent<
      LiquidityPoolWithdrawEvent.InputTuple,
      LiquidityPoolWithdrawEvent.OutputTuple,
      LiquidityPoolWithdrawEvent.OutputObject
    >;
    LiquidityPoolWithdraw: TypedContractEvent<
      LiquidityPoolWithdrawEvent.InputTuple,
      LiquidityPoolWithdrawEvent.OutputTuple,
      LiquidityPoolWithdrawEvent.OutputObject
    >;

    "MarketOrderExecution(address,tuple,uint256)": TypedContractEvent<
      MarketOrderExecutionEvent.InputTuple,
      MarketOrderExecutionEvent.OutputTuple,
      MarketOrderExecutionEvent.OutputObject
    >;
    MarketOrderExecution: TypedContractEvent<
      MarketOrderExecutionEvent.InputTuple,
      MarketOrderExecutionEvent.OutputTuple,
      MarketOrderExecutionEvent.OutputObject
    >;

    "NewMarket(tuple)": TypedContractEvent<
      NewMarketEvent.InputTuple,
      NewMarketEvent.OutputTuple,
      NewMarketEvent.OutputObject
    >;
    NewMarket: TypedContractEvent<
      NewMarketEvent.InputTuple,
      NewMarketEvent.OutputTuple,
      NewMarketEvent.OutputObject
    >;

    "OwnershipTransferred(address,address)": TypedContractEvent<
      OwnershipTransferredEvent.InputTuple,
      OwnershipTransferredEvent.OutputTuple,
      OwnershipTransferredEvent.OutputObject
    >;
    OwnershipTransferred: TypedContractEvent<
      OwnershipTransferredEvent.InputTuple,
      OwnershipTransferredEvent.OutputTuple,
      OwnershipTransferredEvent.OutputObject
    >;
  };
}
